
@using _2024P1.Game
@using AngleSharp.Dom
@using Bunit.Rendering
@using FluentAssertions
@using MudBlazor
@using MudBlazor.Services
@using NSubstitute
@using NUnit.Framework
@using P1.Models
@using P1.Services
@inherits GameBoardTestBase


This is a test for drag/drop interactions with the GameBoard view and its model.


@code {
    private IGameBoardViewModel _gameBoardViewModel;
    
    private List<Card> MockHand => [
        new LetterCard() { Id = 1, Letter = 'a'},
        new LetterCard() { Id = 2, Letter = 'b'},
        new LetterCard() { Id = 3, Letter = 'c'},
        new LetterCard() { Id = 4, Letter = 'd'},
    ];

    [SetUp]
    public void SetUp()
    {
        var handService = new HandService(MockHand);
        handService.HandSize = 4;

        var boardService = new BoardService();
        boardService.BoardSize = 10;
        
        _gameBoardViewModel = new GameBoardViewModel(
            boardService,
            handService,
            Substitute.For<IDeckService>(),
            Substitute.For<IPlayCardsService>()
        );
        
        Services.AddScoped(_ => _gameBoardViewModel);
        Services.AddMudServices();
        JSInterop.Mode = JSRuntimeMode.Loose;
    }


    [Test]
    public void Initially__()
    {
        _cut = Render(@<GameBoard/>);

    }
    
    [Test]
    public void Initially__BoardIsEmpty()
    {
        _cut = Render(@<GameBoard/>);

        CardShouldNotBeIn(cardId: 1, container: BoardStr(0, 0));
        CardShouldNotBeIn(cardId: 2, container: BoardStr(0, 0));
        CardShouldNotBeIn(cardId: 3, container: BoardStr(0, 0));
    }
    
    [Test]
    public void Initially__ExpectedNumDropZones()
    {
        _cut = Render(@<GameBoard/>);
        _cut.Find("#card-1").MouseOver();

        var expectedNumDropZones = _gameBoardViewModel.BoardSize * _gameBoardViewModel.BoardSize;
        _cut.FindAll(".board-drop-zone").Should().HaveCount(expectedNumDropZones);
    }


    [Test]
    public void UserDragsCardOntoBoard__ItMovesFromHandToBoard()
    {
        _cut = Render(@<GameBoard/>);

        DragCardToContainer(1, container: BoardStr(0, 0));

        _cut.WaitForAssertion(() =>
        {
            CardShouldNotBeIn(cardId: 1, container: "hand");
            CardShouldBeIn(cardId: 1, container: BoardStr(0, 0));
        });
    }
    
    [Test]
    public void UserDragsCardOntoBoard__OriginAdjacentDropzonesAppear()
    {
        _cut = Render(@<GameBoard/>);

        DragCardToContainer(1, container: BoardStr(1, 1));
        
        _cut.FindAll(".board-drop-zone").Should().HaveCount(5);
        BoardShouldHaveDropZone(1, 1);
        BoardShouldHaveDropZone(1, 2);
        BoardShouldHaveDropZone(2, 1);
        BoardShouldHaveDropZone(0, 1);
        BoardShouldHaveDropZone(1, 0);
    }
    
    [Test]
    public void UserDragsCardOntoEmptyBoard__OriginAdjacentBoard_RightOfOrigin__Expected3ZonesAppear()
    {
        _cut = Render(@<GameBoard/>);
        // first make origin adjacent zones appear
        DragCardToContainer(1, container: BoardStr(1, 1));
        
        // then drag card to one of them
        DragCardToContainer(2, container: BoardStr(1, 2));
        
        // 5 zones from origin + 3 zones from new position
        _cut.FindAll(".board-drop-zone").Should().HaveCount(8);
        BoardShouldHaveDropZone(1, 3);
        BoardShouldHaveDropZone(2, 2);
        BoardShouldHaveDropZone(0, 2);
    }
    
    [Test]
    public void UserDragsCardOntoEmptyBoard__OriginAdjacentBoard_LeftOfOrigin__Expected3ZonesAppear()
    {
        _cut = Render(@<GameBoard/>);
        DragCardToContainer(1, container: BoardStr(2, 2));
        
        DragCardToContainer(2, container: BoardStr(1, 2));
        
        _cut.FindAll(".board-drop-zone").Should().HaveCount(8);
        BoardShouldHaveDropZone(0, 2);
        BoardShouldHaveDropZone(1, 3);
        BoardShouldHaveDropZone(2, 2);
    }
    
    [Test]
    public void UserDragsCardOntoNonEmptyBoard__DoesntGetPlaced()
    {
        _cut = Render(@<GameBoard/>);
        DragCardToContainer(1, container: BoardStr(0, 0));
        
        DragCardToContainer(2, container: BoardStr(0, 0));
        
        CardShouldBeIn(1, BoardStr(0, 0));
        CardShouldNotBeIn(2, BoardStr(0, 0));
    }
    
    [Test]
    public void UserDragsCardFromBoard__TooDifferentAvailablePosition__ItMoves()
    {
        _cut = Render(@<GameBoard/>);
        DragCardToContainer(1, container: BoardStr(1, 1));
        DragCardToContainer(2, container: BoardStr(0, 1));
        
        DragCardToContainer(2, container: BoardStr(2, 1));
        
        BoardShouldNotHaveCardAt(0, 1);
        BoardShouldHaveCardAt(2, 1);
    }

    [Test]
    public void UserDragsCard__BackToHand_DoesntBreakConnection__ItMovesBackToHand()
    {
        _cut = Render(@<GameBoard/>);
        DragCardToContainer(1, container: BoardStr(0, 0));
    
        DragCardToContainer(1, container: "hand");
    
        BoardShouldNotHaveCardAt(0, 0);
        CardShouldBeIn(1, "hand");
    }

    [Test]
    public void UserDragsCard__BackToHand_ItWouldBreakConnection__DoesntMove()
    {
        _cut = Render(@<GameBoard/>);
        // drag cards such that 1 is in the middle.
        // so if it moves, it will break the 'line'
        DragCardToContainer(1, container: BoardStr(1, 1));
        DragCardToContainer(2, container: BoardStr(0, 1));
        DragCardToContainer(3, container: BoardStr(2, 1));
    
        DragCardToContainer(1, container: "hand");
    
        BoardShouldHaveCardAt(1, 1);
    }
    
    [Test]
    public void UserDragsCard__OriginCard_AdjacentToItself__DoesntMove()
    {
        _cut = Render(@<GameBoard/>);
        DragCardToContainer(1, container: BoardStr(1, 1));
    
        DragCardToContainer(1, container: BoardStr(0, 1));
    
        BoardShouldNotHaveCardAt(0, 1);
    }

    [Test]
    public void UserDragsCard__NonOriginCard_AdjacentToItself_WouldBreakBoard__DoesntMove()
    {
        _cut = Render(@<GameBoard/>);
        DragCardToContainer(1, container: BoardStr(0, 0));
        DragCardToContainer(2, container: BoardStr(1, 0));
    
        DragCardToContainer(2, container: BoardStr(2, 0));
    
        BoardShouldNotHaveCardAt(2, 0);
    }
    
    [Test]
    public void UserDragsCard__EdgeCase1__DoesntMove()
    {
        _cut = Render(@<GameBoard/>);

        DragCardToContainer(1, container: BoardStr(1, 2));
        DragCardToContainer(2, container: BoardStr(0, 2));
        DragCardToContainer(3, container: BoardStr(1, 1));
        DragCardToContainer(4, container: BoardStr(1, 0));
        
        // XX        XX
        //  X   ->   XX
        //  X
        DragCardToContainer(4, container: BoardStr(0, 1));
    
        BoardShouldHaveCardAt(0, 1);
    }
}