
@using _2024P1.Game
@using AngleSharp.Dom
@using FluentAssertions
@using MudBlazor
@using MudBlazor.Services
@using NSubstitute
@using NUnit.Framework
@using P1.Models
@using P1.Services
@inherits GameBoardTestBase


Tests for after a valid turn is reviewed and 'next turn' is clicked for any number of times.
This also involves testing the hand/deck service interplay when drawing cards. 


@code {
    private IGameBoardViewModel _gameBoardViewModel;
    private IBoardService _mockBoardService;
    private IPlayCardsService _mockPlayCardsService;
    private IHandService _handService;
    private IDeckService _deckService;


    [SetUp]
    public void SetUp()
    {
        // Substitutes
        _mockPlayCardsService = Substitute.For<IPlayCardsService>();
        _mockBoardService = Substitute.For<IBoardService>();
        _mockPlayCardsService.GetPlayCardsResult(Arg.Any<Dictionary<(int x, int y), Card>>())
            .Returns(_mockValidPlayResult);
        
        Services.AddScoped<IPlayCardsService>(_ => _mockPlayCardsService);
        Services.AddScoped<ITurnService>(_ => Substitute.For<ITurnService>());
        Services.AddScoped<IBoardService>(_ => _mockBoardService);

        // Services under test
        Services.AddScoped<IHandService, HandService>();
        Services.AddScoped<IDeckService, DeckService>();
        Services.AddScoped<IGameplayRulesService, GameplayRulesService>();
        Services.AddScoped<ICardMovementService, CardMovementService>();
        Services.AddScoped<IGameBoardViewModel, GameBoardViewModel>();

        // External Services
        Services.AddMudServices();
        
        // Config
        JSInterop.Mode = JSRuntimeMode.Loose;
    }
    
    private Dictionary<(int x, int y), Card> _mockBoardState => new()
    {
        { (x: 0, y: 0), new LetterCard { Id = 10, Letter = 'a', Points = 1} },
        { (x: 1, y: 0), new LetterCard { Id = 11, Letter = 'b', Points = 1} },
        { (x: 2, y: 0), new LetterCard { Id = 12, Letter = 'c', Points = 1} },
        { (x: 3, y: 0), new LetterCard { Id = 13, Letter = 'd', Points = 1} },
    };

    private PlayCardsResult _mockValidPlayResult = new()
    {
        IsTurnValid = true,
        PointsTotal = 4,
        CardLineResults =
        [
            new CardLineResult()
            {
                PointsTotal = 4,
                Definition = "definition",
                Word = "abcd",
                CardIds = [10, 11, 12, 13],
                IsValid = true
            }
        ]
    };
    [Test]
    public void Initially__NoError()
    {
        
    }
    
    // TODO: Need to think about what happens when deck doesn't have enough cards
    [Test]
    public void NextTurnClicked__EmptyHand_DeckHasEnoughCards_ValidBoard__HandIsFilledWithTopOfDeck()
    {
        _handService = new HandService([]);
        // board is in a valid state (has any card)
        _mockBoardService.BoardState.Returns(
            new Dictionary<(int x, int y), Card>
            {
                { (1, 1), new LetterCard() { Id = 1, Letter = 'a', Points = 1 } }
            });
        var deckCards = new List<Card> {
            new LetterCard() { Id = 1, Letter = 'a', Points = 1 },
            new LetterCard() { Id = 2, Letter = 'b', Points = 1 },
            new LetterCard() { Id = 3, Letter = 'c', Points = 1 },
            };
        _handService.HandSize = 3;
        _deckService = new DeckService(deckCards);
        Services.AddScoped<IHandService>(_ => _handService);
        Services.AddScoped<IDeckService>(_ => _deckService);
        _cut = Render(@<GameBoard/>);
        _cut.Find("#play-cards-btn").Click();

        _cut.Find("#next-turn-btn").Click();

        _handService.Cards.Should().HaveCount(3);
        _handService.Cards.First().Id.Should().Be(1);
        _handService.Cards.Last().Id.Should().Be(3);
    }
    
    [Test]
    public void NextTurnClicked__HandPartiallyFull_DeckHasEnoughCards__HandIsFilledWithTopOfDeck()
    {
        _handService = new HandService([
            new LetterCard() { Id = 1, Letter = 'a', Points = 1 },
            new LetterCard() { Id = 2, Letter = 'b', Points = 1 },
        ]);
        var deckCards = new List<Card> {
            new LetterCard() { Id = 3, Letter = 'c', Points = 1 },
            new LetterCard() { Id = 4, Letter = 'd', Points = 1 },
            new LetterCard() { Id = 5, Letter = 'e', Points = 1 },
        };
        _handService.HandSize = 4;
        _deckService = new DeckService(deckCards);
        _cut = Render(@<GameBoard/>);
        _cut.Find("#play-cards-btn").Click();

        _cut.Find("#next-turn-btn").Click();

        _handService.Cards.Should().HaveCount(4);
        _handService.Cards.Last().Id.Should().Be(4);
    }

    private List<Card> _mockFullHand =>
    [
        new LetterCard() { Id = 1, Letter = 'a', Points = 1 },
        new LetterCard() { Id = 2, Letter = 'b', Points = 1 },
        new LetterCard() { Id = 3, Letter = 'c', Points = 1 },
        new LetterCard() { Id = 4, Letter = 'd', Points = 1 },
        new LetterCard() { Id = 5, Letter = 'e', Points = 1 },
    ];
    
    [Test]
    public void NextTurnClicked__ValidBoard__PlayedBoardCantBeMoved()
    {
        _handService = new HandService(_mockFullHand);
        _deckService = new DeckService([]);
        _cut = Render(@<GameBoard/>);
        _cut.Find("#play-cards-btn").Click();

        _cut.Find("#next-turn-btn").Click();
        
        DragCardToContainer(10, "hand");
        CardShouldNotBeIn(10, "hand");
        DragCardToContainer(10, BoardStr(4, 0));
        CardShouldNotBeIn(10, BoardStr(4, 0));
    }
    
    [Test]
    public void NextTurnClicked__ValidBoard__PlayedCardsHaveCementedHighlight()
    {
        _handService = new HandService(_mockFullHand);
        _deckService = new DeckService([]);
        _cut = Render(@<GameBoard/>);
        _cut.Find("#play-cards-btn").Click();

        _cut.Find("#next-turn-btn").Click();

        var boardIds = _mockBoardState.Select(kv => kv.Value.Id);
        _gameBoardViewModel.Cards.Where(c => boardIds.Contains(c.Id))
            .Should().AllSatisfy(c => c.Highlight.Should().Be(CardHighlight.Cemented));

    }
}